snippet adaprob "Sample buffered reader main"
	import java.io.BufferedReader;
	import java.io.IOException;
	import java.io.InputStreamReader;

	public class Main {

		public static void main (String[] args) throws IOException {

			BufferedReader input = new BufferedReader(new InputStreamReader(System.in));

			int ${1:nLines} = Integer.parseInt(input.readLine());

			for (int i = 0; i < $1; i++) {

				// Code here...
				${0}

			}

		}

	}

snippet adabfs "Graph Breath-First-Search base algorithm"
	private void processNode(int v) {

		// Process node here...
		${0}
	}

	private void bfsTraversal(List<List<Integer>> graph) {

		// Attributes
		Object[] attributes = new Object[]{
			new boolean[E] // Found
		};
		boolean[] found = ((boolean[]) attributes[0]);

		for (int v = 0; v < graph.size(); v++)
			found[v] = false;

		for (int v=0; v < E; v++)
			if (!found[v])
				bfsExplore(graph, attributes, v);

	}

	private void bfsExplore(List<List<Integer>> graph, Object[] attributes, int root) {

		boolean[] found = ((boolean[]) attributes[0]);

		Queue<Integer> waiting = new LinkedList<>();
		
		found[root] = true;
		waiting.add(root);

		do {
			int v = waiting.remove();

			processNode(v);

			for (int vAdj : graph.get(v))
				if (!found[vAdj]) {

					found[vAdj] = true;
					waiting.add(vAdj);
				}

		} while (!waiting.isEmpty());

	}

snippet adadfs "Graph Depth-First-Search algorithm base"
	private void processNode(int v) {

		// Process node here...
		${0}
	}

	private void dfsTraversal(List<List<Integer>> graph) {

		// Attributes
		Object[] attributes = new Object[]{
			new boolean[E] // Found
		};
		boolean[] found = ((boolean[]) attributes[0]);

		for (int v = 0; v < E; v++)
			found[v] = false;

		for (int v = 0; v < E; v++)
			if (!found[v])
				dfsExplore(graph, attributes, v);

	}

	private void dfsExplore(List<List<Integer>> graph, Object[] attributes, int root) {

		boolean[] found = ((boolean[]) attributes[0]);

		Stack<Integer> s = new Stack<>();

		s.push(v);

		do {

			v = s.pop();
			if (!found[v]) {

				processNode(v);

				found[v] = true;
				for (Integer vAdj : graph.get(v))
					if (!found[vAdj])
						s.push(vAdj);
			}

		} while (!s.empty());

	}
